{"version":3,"file":"sjs.js","sources":["../src/_utils.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/sjs.mjs"],"sourcesContent":["\n/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  const { length } = path;\n\n  let str = 'obj';\n\n  for (let i = 0; i < length; i++) {\n    str = str.replace(/^/, '(');\n    str += ` || {}).${path[i]}`;\n  }\n\n  return eval(`((obj) => ${str})`);\n};\n\n/**\n * `_makeArraySerializer` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n *\n * @param {array} array - Array to serialize.\n * @param {any} method - `sjs` serializer.\n */\nconst _makeArraySerializer = (serializer) => {\n  if (serializer instanceof Function) {\n    return (array) => {\n      // Stringifying more complex array using the provided sjs schema\n      let acc = '';\n      const { length } = array;\n      for (let i = 0; i < length - 1; i++) {\n        acc += `${serializer(array[i])},`;\n      }\n\n      // Prevent slice for removing unnecessary comma.\n      acc += serializer(array[length - 1]);\n      return `[${acc}]`;\n    };\n  }\n\n  return array => JSON.stringify(array);\n};\n\nconst TYPES = [\n  'number',\n  'string',\n  'boolean',\n  'array',\n  'null',\n];\n\nconst attr = (arg, serializer) => {\n  if (!TYPES.includes(arg)) {\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\", \"null\". received \"${arg}\" instead`);\n  }\n\n  if (arg === 'array') {\n    return _makeArraySerializer(serializer);\n  }\n\n  return arg;\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst escape = (regex = defaultRegex) => str => str.replace(regex, char => '\\\\' + char);\n\nexport {\n  _find,\n  escape,\n  attr,\n};\n","import { _find } from './_utils';\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification serializers that are lost during preparation.\n */\nexport default (preparedSchema, originalSchema) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const allowedValues = new Set([\n    'number__sjs',\n    'string__sjs',\n    'boolean__sjs',\n    'array__sjs',\n  ]);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    if (allowedValues.has(obj)) {\n      const usedAcc = Array.from(acc);\n      const find = _find(usedAcc);\n      const serializer = find(originalSchema);\n\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray: serializer instanceof Function,\n\n        // If the current prop is an array, the array stringification serializer is stored too.\n        // The serializer for the array stringification, in SJS, is always stored at 0 position.\n        serializer,\n\n        // The find function is the function needed to reach that specific property\n        // inside the object.\n        find,\n\n        name: usedAcc[usedAcc.length - 1],\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(preparedSchema);\n\n  return queue;\n};\n","/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nexport default (str, queue) => str\n  // Matching prepared properties and replacing with target with or without\n  // double quotes.\n  // => Avoiding unnecessary concatenation of doublequotes during serialization.\n  .replace(/\"(string__sjs|number__sjs|boolean__sjs|array__sjs)\"|\\[(.*?)\\]/gm, (type) => {\n    if (type === '\"string__sjs\"') {\n      return '\"__par__\"';\n    }\n    return '__par__';\n  })\n  .split('__par__')\n  .map((chunk, index, chunks) => {\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = `(\"${(queue[index] || {}).name}\":(\\\"?))$`;\n    const matchWhenLast = `(\\,?)${matchProp}`;\n\n    // Check if current chunk is the last one inside a nested property\n    const isLast = /^(\"}|})/.test(chunks[index + 1] || '');\n\n    // If the chunk is the last one the `isUndef` case should match\n    // the preceding comma too.\n    const matchPropRe = new RegExp(isLast ? matchWhenLast : matchProp);\n\n    // 3 possibilities after arbitrary property:\n    // - \", => non-last string property\n    // - , => non-last non-string property\n    // - \" => last string property\n    const matchStartRe = /^(\\\"\\,|\\,|\\\")/;\n\n    return {\n      // notify that the chunk preceding the current one has not\n      // its corresponding property undefined.\n      // => This is a V8 optimization as it's way faster writing\n      // the value of a property than writing the entire property.\n      flag: false,\n      pure: chunk,\n      // Without initial part\n      prevUndef: chunk.replace(matchStartRe, ''),\n      // Without property chars\n      isUndef: chunk.replace(matchPropRe, ''),\n      // Only remaining chars (can be zero chars)\n      bothUndef: chunk\n        .replace(matchStartRe, '')\n        .replace(matchPropRe, ''),\n    };\n  });\n","import _makeQueue from './_makeQueue';\nimport _makeChunks from './_makeChunks';\nimport { attr, escape } from './_utils';\n\n/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst select = chunks => (value, index) => {\n  const chunk = chunks[index];\n\n  if (typeof value !== 'undefined') {\n    if (chunk.flag) {\n      return chunk.prevUndef + value;\n    }\n    return chunk.pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (chunk.flag) {\n    return chunk.bothUndef;\n  }\n  return chunk.isUndef;\n};\n\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const preparedString = JSON.stringify(schema, (_, value) => {\n    if (typeof value === 'object') return value;\n    return value instanceof Function\n      ? 'array__sjs'\n      : `${value}__sjs`;\n  });\n  const preparedSchema = JSON.parse(preparedString);\n\n  // INVESTIGATION FROM HEREEE\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(preparedSchema, schema);\n  const { length } = queue;\n  const chunks = _makeChunks(preparedString, queue);\n  const selectChunk = select(chunks);\n\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { serializer, isArray, find } = queue[i];\n      const raw = find(obj);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? serializer(raw)\n        : raw;\n      temp += selectChunk(ready, i);\n\n      i += 1;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport {\n  sjs,\n  attr,\n  escape,\n};\n"],"names":["const","_find","path","length","str","i","replace","eval","_makeArraySerializer","serializer","Function","array","acc","JSON","stringify","TYPES","attr","arg","includes","Error","defaultRegex","RegExp","escape","regex","char","preparedSchema","originalSchema","queue","allowedValues","Set","scoped","obj","has","Object","keys","map","prop","usedAcc","Array","from","find","push","isArray","name","type","split","chunk","index","chunks","matchProp","matchWhenLast","isLast","test","matchPropRe","matchStartRe","flag","pure","prevUndef","isUndef","bothUndef","select","value","sjs","schema","preparedString","_","parse","_makeQueue","_makeChunks","selectChunk","temp","raw","ready"],"mappings":"AAYAA,IAAMC,eAASC,UACLC,uBAEJC,IAAM,MAEDC,EAAI,EAAGA,EAAIF,OAAQE,IAC1BD,IAAMA,IAAIE,QAAQ,IAAK,KACvBF,KAAQ,WAAUF,KAAKG,UAGlBE,kBAAkBH,UAUrBI,8BAAwBC,UACxBA,aAAsBC,kBAChBC,WAEFC,EAAM,cAEDP,EAAI,EAAGA,EAAIF,EAAS,EAAGE,IAC9BO,GAAUH,EAAWE,EAAMN,mBAI7BO,GAAOH,EAAWE,EAAMR,EAAS,mBAK9BQ,UAASE,KAAKC,UAAUH,KAG3BI,MAAQ,CACZ,SACA,SACA,UACA,QACA,QAGIC,cAAQC,EAAKR,OACZM,MAAMG,SAASD,SACZ,IAAIE,2EAA2EF,qBAG3E,UAARA,EACKT,qBAAqBC,GAGvBQ,GAKHG,aAAe,IAAIC,OAAO,uBAAwB,MAClDC,gBAAUC,yBAAQH,uBAAiBhB,UAAOA,EAAIE,QAAQiB,WAAOC,SAAQ,KAAOA,0BClElEC,EAAgBC,OACxBC,EAAQ,GAKRC,EAAgB,IAAIC,IAAI,CAC5B,cACA,cACA,eACA,+BAKQC,EAAOC,EAAKnB,qBAAM,KACtBgB,EAAcI,IAAID,UAyBfE,OACJC,KAAKH,GACLI,aAAIC,UAAQN,EAAOC,EAAIK,GAAWxB,UAAKwB,WA1BlCC,EAAUC,MAAMC,KAAK3B,GACrB4B,EAAOvC,MAAMoC,GACb5B,EAAa+B,EAAKd,GAExBC,EAAMc,KAAK,CAETC,QAASjC,aAAsBC,oBAI/BD,OAIA+B,EAEAG,KAAMN,EAAQA,EAAQlC,OAAS,MAWlCsB,GAEIE,wBChDOvB,EAAKuB,UAAUvB,EAI5BE,QAAQ,2EAAoEsC,SAC9D,kBAATA,EACK,YAEF,YAERC,MAAM,WACNV,aAAKW,EAAOC,EAAOC,OAIZC,EAAa,MAAKtB,EAAMoB,IAAU,oBAClCG,EAAiB,OAAOD,EAGxBE,EAAS,UAAUC,KAAKJ,EAAOD,EAAQ,IAAM,IAI7CM,EAAc,IAAIhC,OAAO8B,EAASD,EAAgBD,GAMlDK,EAAe,sBAEd,CAKLC,MAAM,EACNC,KAAMV,EAENW,UAAWX,EAAMxC,QAAQgD,EAAc,IAEvCI,QAASZ,EAAMxC,QAAQ+C,EAAa,IAEpCM,UAAWb,EACRxC,QAAQgD,EAAc,IACtBhD,QAAQ+C,EAAa,QCrCxBO,gBAASZ,mBAAWa,EAAOd,OACzBD,EAAQE,EAAOD,eAEA,IAAVc,EACLf,EAAMS,KACDT,EAAMW,UAAYI,EAEpBf,EAAMU,KAAOK,GAKtBb,EAAOD,EAAQ,GAAGQ,MAAO,EAErBT,EAAMS,KACDT,EAAMa,UAERb,EAAMY,WAMTI,aAAOC,OACLC,EAAiBnD,KAAKC,UAAUiD,WAASE,EAAGJ,SAC3B,iBAAVA,EAA2BA,EAC/BA,aAAiBnD,SACpB,aACGmD,YAEHpC,EAAiBZ,KAAKqD,MAAMF,GAO5BrC,EAAQwC,WAAW1C,EAAgBsC,cAEnCf,EAASoB,YAAYJ,EAAgBrC,GACrC0C,EAAcT,OAAOZ,mBAGnBjB,WACFuC,EAAO,GAGPjE,EAAI,EAEFA,IAAMF,GADC,OAE2BwB,EAAMtB,8BACtCkE,GAAM/B,UAAKT,GAIXyC,EAAQ9B,EACVjC,EAAW8D,GACXA,EACJD,GAAQD,EAAYG,EAAOnE,GAE3BA,GAAK,QAG2B2C,EAAOA,EAAO7C,OAAS,UAElDmE"}