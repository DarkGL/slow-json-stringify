{"version":3,"file":"sjs.js","sources":["../src/_utils.mjs","../src/_prepareString.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/sjs.mjs"],"sourcesContent":["\n/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  const { length } = path;\n\n  let str = 'obj';\n\n  for (let i = 0; i < length; i++) {\n    str = str.replace(/^/, '(');\n    str += ` || {}).${path[i]}`;\n  }\n\n  return eval(`((obj) => ${str})`);\n};\n\n/**\n * `_makeArr` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n *\n * @param {array} array - Array to serialize.\n * @param {any} method - `sjs` serializer.\n */\nconst _makeArr = (array, method) => {\n  if (method === 'array-simple') return JSON.stringify(array);\n\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  const { length } = array;\n  for (let i = 0; i < length - 1; i++) {\n    acc += `${method(array[i])},`;\n  }\n\n  // Prevent slice for removing unnecessary comma.\n  acc += method(array[length - 1]);\n\n  return `[${acc}]`;\n};\n\n/**\n * @param {any} value - current schema value to validate.\n */\nconst _validator = (value) => {\n  // Declaring allowed types.\n  const allowedTypes = new Set([\n    'number',\n    'string',\n    'boolean',\n    'array-simple',\n    'function',\n  ]);\n\n  if (Array.isArray(value)) {\n    if (allowedTypes.has(value[0]) || allowedTypes.has(typeof value[0])) return;\n\n    // Throwing if inside array is found anything else than \"array-simple\" or new sjs schema\n    throw new Error(`Expected either \"array-simple\" or a function. received ${value}`);\n  } else if (typeof value !== 'function' && !allowedTypes.has(value)) {\n    // Throwing on illegal types\n    // => Mainly protecting users from typo.\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\". received ${value}`);\n  }\n};\n\nconst TYPES = [\n  'number',\n  'string',\n  'boolean',\n  'array',\n  'null',\n];\n\nconst attr = (arg, serializer) => {\n  if (!TYPES.includes(arg)) {\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\", \"null\". received ${arg} instead`);\n  }\n\n  if (arg === 'array' && serializer instanceof Function) {\n    return [serializer];\n  }\n\n  return arg;\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst escape = (regex = defaultRegex) => str => str.replace(regex, char => '\\\\' + char);\n\nexport {\n  _find,\n  _makeArr,\n  _validator,\n  escape,\n  attr,\n};\n","import { _validator } from './_utils';\n\n/**\n * @param {object} schema - provided schema to validate.\n */\nexport default schema => JSON.stringify(schema, (_, value) => {\n  const isArray = Array.isArray(value);\n  if (typeof value !== 'object' || isArray) {\n    // Check if the provided schema is correct\n    _validator(value);\n\n    if (isArray) return value;\n\n    console.log(value);\n\n    // Type checking is useful as if not performed the resulting string\n    // will have all the function text inside it.\n    // Adding __sjs at the end of the value as there could be an object\n    // property called `string` or `number`, etc...\n    // Adding __sjs at the end is a proof of value not being also an object property.\n    return typeof value === 'function' ? value : `${value}__sjs`;\n  }\n  return value;\n});\n","import { _find } from './_utils';\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification methods that are lost during preparation.\n */\nexport default (preparedSchema, originalSchema) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const allowedValues = new Set([\n    'number__sjs',\n    'string__sjs',\n    'boolean__sjs',\n  ]);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    const isArray = Array.isArray(obj);\n    if (allowedValues.has(obj) || isArray) {\n      const usedAcc = Array.from(acc);\n      const find = _find(usedAcc);\n\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray,\n        // If the current prop is an array, the array stringification method is stored too.\n        // The method for the array stringification, in SJS, is always stored at 0 position.\n        method: isArray && find(originalSchema)[0],\n\n        // The find function is the function needed to reach that specific property\n        // inside the object.\n        find,\n\n        name: usedAcc[usedAcc.length - 1],\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(preparedSchema);\n\n  return queue;\n};\n","/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nexport default (str, queue) => str\n  // Matching prepared properties and replacing with target with or without\n  // double quotes.\n  // => Avoiding unnecessary concatenation of doublequotes during serialization.\n  .replace(/\"(string__sjs|number__sjs|boolean__sjs)\"|\\[(.*?)\\]/gm, (type) => {\n    if (type === '\"string__sjs\"') {\n      return '\"__par__\"';\n    }\n    return '__par__';\n  })\n  .split('__par__')\n  .map((chunk, index, chunks) => {\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = `(\"${(queue[index] || {}).name}\":(\\\"?))$`;\n    const matchWhenLast = `(\\,?)${matchProp}`;\n\n    // Check if current chunk is the last one inside a nested property\n    const isLast = /^(\"}|})/.test(chunks[index + 1] || '');\n\n    // If the chunk is the last one the `isUndef` case should match\n    // the preceding comma too.\n    const matchPropRe = new RegExp(isLast ? matchWhenLast : matchProp);\n\n    // 3 possibilities after arbitrary property:\n    // - \", => non-last string property\n    // - , => non-last non-string property\n    // - \" => last string property\n    const matchStartRe = /^(\\\"\\,|\\,|\\\")/;\n\n    return {\n      // notify that the chunk preceding the current one has not\n      // its corresponding property undefined.\n      // => This is a V8 optimization as it's way faster writing\n      // the value of a property than writing the entire property.\n      flag: false,\n      pure: chunk,\n      // Without initial part\n      prevUndef: chunk.replace(matchStartRe, ''),\n      // Without property chars\n      isUndef: chunk.replace(matchPropRe, ''),\n      // Only remaining chars (can be zero chars)\n      bothUndef: chunk\n        .replace(matchStartRe, '')\n        .replace(matchPropRe, ''),\n    };\n  });\n","import _prepareString from './_prepareString';\nimport _makeQueue from './_makeQueue';\nimport _makeChunks from './_makeChunks';\nimport { _makeArr, attr, escape } from './_utils';\n\n/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst select = chunks => (value, index) => {\n  const chunk = chunks[index];\n\n  if (typeof value !== 'undefined') {\n    if (chunk.flag) {\n      return chunk.prevUndef + value;\n    }\n    return chunk.pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (chunk.flag) {\n    return chunk.bothUndef;\n  }\n  return chunk.isUndef;\n};\n\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const preparedString = _prepareString(schema);\n  const preparedSchema = JSON.parse(preparedString);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(preparedSchema, schema);\n  const { length } = queue;\n  const chunks = _makeChunks(preparedString, queue);\n  const selectChunk = select(chunks);\n\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { method, isArray, find } = queue[i];\n      const raw = find(obj);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? _makeArr(raw, method)\n        : raw;\n      temp += selectChunk(ready, i);\n\n      i += 1;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport {\n  sjs,\n  attr,\n  escape,\n};\n"],"names":["const","_find","path","length","str","i","replace","eval","_makeArr","array","method","JSON","stringify","acc","_validator","value","allowedTypes","Set","Array","isArray","has","Error","TYPES","attr","arg","serializer","includes","Function","defaultRegex","RegExp","escape","regex","char","schema","_","console","log","preparedSchema","originalSchema","queue","allowedValues","scoped","obj","Object","keys","map","prop","usedAcc","from","find","push","name","type","split","chunk","index","chunks","matchProp","matchWhenLast","isLast","test","matchPropRe","matchStartRe","flag","pure","prevUndef","isUndef","bothUndef","select","sjs","preparedString","_prepareString","parse","_makeQueue","_makeChunks","selectChunk","temp","raw","ready"],"mappings":"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"}