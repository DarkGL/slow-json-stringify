{"version":3,"file":"sjs.umd.js","sources":["../src/_utils.mjs","../src/_prepareString.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/sjs.mjs"],"sourcesContent":["\n/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  const { length } = path;\n\n  let str = 'obj';\n\n  for (let i = 0; i < length; i++) {\n    str = str.replace(/^/, '(');\n    str += ` || {}).${path[i]}`;\n  }\n\n  return eval(`((obj) => ${str})`);\n};\n\n/**\n * `_makeArr` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n *\n * @param {array} array - Array to serialize.\n * @param {any} method - `sjs` serializer.\n */\nconst _makeArr = (array, method) => {\n  if (method === 'array-simple') return JSON.stringify(array);\n\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  const { length } = array;\n  for (let i = 0; i < length - 1; i++) {\n    acc += `${method(array[i])},`;\n  }\n\n  // Prevent slice for removing unnecessary comma.\n  acc += method(array[length - 1]);\n\n  return `[${acc}]`;\n};\n\n/**\n * @param {any} value - current schema value to validate.\n */\nconst _validator = (value) => {\n  // Declaring allowed types.\n  const allowedTypes = new Set([\n    'number',\n    'string',\n    'boolean',\n    'array-simple',\n    'function',\n  ]);\n\n  if (Array.isArray(value)) {\n    if (allowedTypes.has(value[0]) || allowedTypes.has(typeof value[0])) return;\n\n    // Throwing if inside array is found anything else than \"array-simple\" or new sjs schema\n    throw new Error(`Expected either \"array-simple\" or a function. received ${value}`);\n  } else if (typeof value !== 'function' && !allowedTypes.has(value)) {\n    // Throwing on illegal types\n    // => Mainly protecting users from typo.\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\". received ${value}`);\n  }\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst escape = (regex = defaultRegex) => str => str.replace(regex, char => '\\\\' + char);\n\nexport {\n  _find,\n  _makeArr,\n  _validator,\n  escape,\n};\n","import { _validator } from './_utils';\n\n/**\n * @param {object} schema - provided schema to validate.\n */\nexport default schema => JSON.stringify(schema, (_, value) => {\n  const isArray = Array.isArray(value);\n  if (typeof value !== 'object' || isArray) {\n    // Check if the provided schema is correct\n    _validator(value);\n\n    if (isArray) return value;\n\n    // Type checking is useful as if not performed the resulting string\n    // will have all the function text inside it.\n    // Adding __sjs at the end of the value as there could be an object\n    // property called `string` or `number`, etc...\n    // Adding __sjs at the end is a proof of value not being also an object property.\n    return typeof value === 'function' ? value : `${value}__sjs`;\n  }\n  return value;\n});\n","import { _find } from './_utils';\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification methods that are lost during preparation.\n */\nexport default (preparedSchema, originalSchema) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const allowedValues = new Set([\n    'number__sjs',\n    'string__sjs',\n    'boolean__sjs',\n  ]);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    const isArray = Array.isArray(obj);\n    if (allowedValues.has(obj) || isArray) {\n      const usedAcc = Array.from(acc);\n      const find = _find(usedAcc);\n\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray,\n        // If the current prop is an array, the array stringification method is stored too.\n        // The method for the array stringification, in SJS, is always stored at 0 position.\n        method: isArray && find(originalSchema)[0],\n\n        // The find function is the function needed to reach that specific property\n        // inside the object.\n        find,\n\n        name: usedAcc[usedAcc.length - 1],\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(preparedSchema);\n\n  return queue;\n};\n","/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nexport default (str, queue) => str\n  // Matching prepared properties and replacing with target with or without\n  // double quotes.\n  // => Avoiding unnecessary concatenation of doublequotes during serialization.\n  .replace(/\"(string__sjs|number__sjs|boolean__sjs)\"|\\[(.*?)\\]/gm, (type) => {\n    if (type === '\"string__sjs\"') {\n      return '\"__par__\"';\n    }\n    return '__par__';\n  })\n  .split('__par__')\n  .map((chunk, index) => {\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = new RegExp(`\"${(queue[index] || {}).name}\":(\\\"?)$`);\n\n    // 3 possibilities after arbitrary property:\n    // - \", => non-last string property\n    // - , => non-last non-string property\n    // - \" => last string property\n    const matchStart = /^(\\\"\\,|\\,|\\\")/;\n\n    return {\n      pure: chunk,\n      prevUndef: chunk.replace(matchStart, ''),\n      isUndef: chunk.replace(matchProp, ''),\n      bothUndef: chunk\n        .replace(matchStart, '')\n        .replace(matchProp, ''),\n    };\n  });\n","import _prepareString from './_prepareString';\nimport _makeQueue from './_makeQueue';\nimport _makeChunks from './_makeChunks';\nimport { _makeArr, escape } from './_utils';\n\n/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst select = chunks => (value, index) => {\n  const { pure, flag, isUndef, prevUndef, bothUndef } = chunks[index];\n\n  if (typeof value !== 'undefined') {\n    if (flag) {\n      return prevUndef + value;\n    }\n    return pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (flag) {\n    return bothUndef;\n  }\n  return isUndef;\n};\n\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const preparedString = _prepareString(schema);\n  const preparedSchema = JSON.parse(preparedString);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(preparedSchema, schema);\n  const { length } = queue;\n\n  const chunks = _makeChunks(preparedString, queue);\n  const selectChunk = select(chunks);\n\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { method, isArray, find } = queue[i];\n      const raw = find(obj);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? _makeArr(raw, method)\n        : raw;\n      temp += selectChunk(ready, i);\n\n      i += 1;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport {\n  sjs,\n  escape,\n};\n"],"names":["const","_find","path","length","str","i","replace","eval","_makeArr","array","method","JSON","stringify","acc","_validator","value","allowedTypes","Set","Array","isArray","has","Error","defaultRegex","RegExp","escape","regex","char","schema","_","preparedSchema","originalSchema","queue","allowedValues","scoped","obj","Object","keys","map","prop","usedAcc","from","find","push","name","type","split","chunk","index","matchProp","matchStart","pure","prevUndef","isUndef","bothUndef","select","chunks","flag","sjs","preparedString","_prepareString","parse","_makeQueue","_makeChunks","selectChunk","temp","raw","ready"],"mappings":"6LAYAA,IAAMC,eAASC,UACLC,uBAEJC,IAAM,MAEDC,EAAI,EAAGA,EAAIF,OAAQE,IAC1BD,IAAMA,IAAIE,QAAQ,IAAK,KACvBF,KAAQ,WAAUF,KAAKG,UAGlBE,kBAAkBH,UAUrBI,kBAAYC,EAAOC,MACR,iBAAXA,EAA2B,OAAOC,KAAKC,UAAUH,WAGjDI,EAAM,cAEDR,EAAI,EAAGA,EAAIF,EAAS,EAAGE,IAC9BQ,GAAUH,EAAOD,EAAMJ,mBAIzBQ,GAAOH,EAAOD,EAAMN,EAAS,UAQzBW,oBAAcC,OAEZC,EAAe,IAAIC,IAAI,CAC3B,SACA,SACA,UACA,eACA,gBAGEC,MAAMC,QAAQJ,GAAQ,IACpBC,EAAaI,IAAIL,EAAM,KAAOC,EAAaI,WAAWL,EAAM,IAAK,aAG/D,IAAIM,gEAAgEN,GACrE,GAAqB,mBAAVA,IAAyBC,EAAaI,IAAIL,SAGpD,IAAIM,kEAAkEN,IAM1EO,aAAe,IAAIC,OAAO,uBAAwB,MAClDC,gBAAUC,yBAAQH,uBAAiBlB,UAAOA,EAAIE,QAAQmB,WAAOC,SAAQ,KAAOA,8BCvEnEC,UAAUhB,KAAKC,UAAUe,WAASC,EAAGb,OAC5CI,EAAUD,MAAMC,QAAQJ,SACT,iBAAVA,GAAsBI,GAE/BL,WAAWC,GAEPI,EAAgBJ,EAOI,mBAAVA,EAAuBA,EAAWA,WAE3CA,yBCZOc,EAAgBC,OACxBC,EAAQ,GAKRC,EAAgB,IAAIf,IAAI,CAC5B,cACA,cACA,iCAKQgB,EAAOC,EAAKrB,kBAAM,QACpBM,EAAUD,MAAMC,QAAQe,OAC1BF,EAAcZ,IAAIc,KAAQf,SAuBvBgB,OACJC,KAAKF,GACLG,aAAIC,UAAQL,EAAOC,EAAII,GAAWzB,UAAKyB,WAxBlCC,EAAUrB,MAAMsB,KAAK3B,GACrB4B,EAAOxC,MAAMsC,GAEnBR,EAAMW,KAAK,SAETvB,EAGAT,OAAQS,GAAWsB,EAAKX,GAAgB,QAIxCW,EAEAE,KAAMJ,EAAQA,EAAQpC,OAAS,MAWlC0B,GAEIE,wBC9CO3B,EAAK2B,UAAU3B,EAI5BE,QAAQ,gEAAyDsC,SACnD,kBAATA,EACK,YAEF,YAERC,MAAM,WACNR,aAAKS,EAAOC,OAILC,EAAY,IAAIzB,YAAYQ,EAAMgB,IAAU,oBAM5CE,EAAa,sBAEZ,CACLC,KAAMJ,EACNK,UAAWL,EAAMxC,QAAQ2C,EAAY,IACrCG,QAASN,EAAMxC,QAAQ0C,EAAW,IAClCK,UAAWP,EACRxC,QAAQ2C,EAAY,IACpB3C,QAAQ0C,EAAW,QCpBtBM,gBAASC,mBAAWxC,EAAOgC,SACuBQ,EAAOR,kDAExC,IAAVhC,EACLyC,cACiBzC,SAEPA,GAKhBwC,EAAOR,EAAQ,GAAGS,MAAO,EAErBA,EACKH,EAEFD,KAMHK,aAAO9B,OACL+B,EAAiBC,eAAehC,GAChCE,EAAiBlB,KAAKiD,MAAMF,GAK5B3B,EAAQ8B,WAAWhC,EAAgBF,cAGnC4B,EAASO,YAAYJ,EAAgB3B,GACrCgC,EAAcT,OAAOC,mBAGnBrB,WACF8B,EAAO,GAGP3D,EAAI,EAEFA,IAAMF,GADC,OAEuB4B,EAAM1B,0BAClC4D,GAAMxB,UAAKP,GAIXgC,EAAQ/C,EACVX,SAASyD,EAAKvD,GACduD,EACJD,GAAQD,EAAYG,EAAO7D,GAE3BA,GAAK,QAG2BkD,EAAOA,EAAOpD,OAAS,UAElD6D"}