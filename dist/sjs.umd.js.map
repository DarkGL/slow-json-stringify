{"version":3,"file":"sjs.umd.js","sources":["../src/_prepare.js","../src/_utils.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/_select.js","../src/sjs.mjs"],"sourcesContent":["\n/**\n * `_prepare` - aims to normalize the schema provided by the user.\n * It will convert the schema in both a parseable string and an object\n * useable for making the chunks needed for the serialization part.\n * @param {object} schema - user provided schema\n */\nconst _prepare = (schema) => {\n  const preparedString = JSON.stringify(schema, (_, value) => {\n    if (typeof value === 'object') return value;\n    return value instanceof Function\n      ? 'array__sjs'\n      : `${value}__sjs`;\n  });\n\n  const preparedSchema = JSON.parse(preparedString);\n\n  return {\n    preparedString,\n    preparedSchema,\n  };\n};\n\nexport default _prepare;\n","\n/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  const { length } = path;\n\n  let str = 'obj';\n\n  for (let i = 0; i < length; i++) {\n    str = str.replace(/^/, '(');\n    str += ` || {}).${path[i]}`;\n  }\n\n  return eval(`((obj) => ${str})`);\n};\n\n/**\n * `_makeArraySerializer` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n *\n * @param {array} array - Array to serialize.\n * @param {any} method - `sjs` serializer.\n */\nconst _makeArraySerializer = (serializer) => {\n  if (serializer instanceof Function) {\n    return (array) => {\n      // Stringifying more complex array using the provided sjs schema\n      let acc = '';\n      const { length } = array;\n      for (let i = 0; i < length - 1; i++) {\n        acc += `${serializer(array[i])},`;\n      }\n\n      // Prevent slice for removing unnecessary comma.\n      acc += serializer(array[length - 1]);\n      return `[${acc}]`;\n    };\n  }\n\n  return array => JSON.stringify(array);\n};\n\nconst TYPES = [\n  'number',\n  'string',\n  'boolean',\n  'array',\n  'null',\n];\n\nconst attr = (arg, serializer) => {\n  if (!TYPES.includes(arg)) {\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\", \"null\". received \"${arg}\" instead`);\n  }\n\n  if (arg === 'array') {\n    return _makeArraySerializer(serializer);\n  }\n\n  return arg;\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst escape = (regex = defaultRegex) => str => str.replace(regex, char => '\\\\' + char);\n\nexport {\n  _find,\n  escape,\n  attr,\n};\n","import { _find } from './_utils';\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification serializers that are lost during preparation.\n */\nexport default (preparedSchema, originalSchema) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const allowedValues = new Set([\n    'number__sjs',\n    'string__sjs',\n    'boolean__sjs',\n    'null__sjs',\n    'array__sjs',\n  ]);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    if (allowedValues.has(obj)) {\n      const usedAcc = Array.from(acc);\n      const find = _find(usedAcc);\n      const serializer = find(originalSchema);\n\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray: serializer instanceof Function,\n\n        // If the current prop is an array, the array stringification serializer is stored too.\n        // The serializer for the array stringification, in SJS, is always stored at 0 position.\n        serializer,\n\n        // The find function is the function needed to reach that specific property\n        // inside the object.\n        find,\n\n        name: usedAcc[usedAcc.length - 1],\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(preparedSchema);\n\n  return queue;\n};\n","/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nexport default (str, queue) => str\n  // Matching prepared properties and replacing with target with or without\n  // double quotes.\n  // => Avoiding unnecessary concatenation of doublequotes during serialization.\n  .replace(/\"\\w+__sjs\"/gm, type => (/string/.test(type) ? '\"__par__\"' : '__par__'))\n  .split('__par__')\n  .map((chunk, index, chunks) => {\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = `(\"${(queue[index] || {}).name}\":(\\\"?))$`;\n    const matchWhenLast = `(\\,?)${matchProp}`;\n\n    // Check if current chunk is the last one inside a nested property\n    const isLast = /^(\"}|})/.test(chunks[index + 1] || '');\n\n    // If the chunk is the last one the `isUndef` case should match\n    // the preceding comma too.\n    const matchPropRe = new RegExp(isLast ? matchWhenLast : matchProp);\n\n    // 3 possibilities after arbitrary property:\n    // - \", => non-last string property\n    // - , => non-last non-string property\n    // - \" => last string property\n    const matchStartRe = /^(\\\"\\,|\\,|\\\")/;\n\n    return {\n      // notify that the chunk preceding the current one has not\n      // its corresponding property undefined.\n      // => This is a V8 optimization as it's way faster writing\n      // the value of a property than writing the entire property.\n      flag: false,\n      pure: chunk,\n      // Without initial part\n      prevUndef: chunk.replace(matchStartRe, ''),\n      // Without property chars\n      isUndef: chunk.replace(matchPropRe, ''),\n      // Only remaining chars (can be zero chars)\n      bothUndef: chunk\n        .replace(matchStartRe, '')\n        .replace(matchPropRe, ''),\n    };\n  });\n","/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst _select = chunks => (value, index) => {\n  const chunk = chunks[index];\n\n  if (typeof value !== 'undefined') {\n    if (chunk.flag) {\n      return chunk.prevUndef + value;\n    }\n    return chunk.pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (chunk.flag) {\n    return chunk.bothUndef;\n  }\n  return chunk.isUndef;\n};\n\nexport default _select;\n","import _prepare from './_prepare';\nimport _makeQueue from './_makeQueue';\nimport _makeChunks from './_makeChunks';\nimport _select from './_select';\nimport { attr, escape } from './_utils';\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const { preparedString, preparedSchema } = _prepare(schema);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(preparedSchema, schema);\n  const chunks = _makeChunks(preparedString, queue);\n  console.log(chunks);\n  const selectChunk = _select(chunks);\n\n  const { length } = queue;\n\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { serializer, isArray, find } = queue[i];\n      const raw = find(obj);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? serializer(raw)\n        : raw;\n      temp += selectChunk(ready, i);\n\n      i += 1;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport {\n  sjs,\n  attr,\n  escape,\n};\n"],"names":["const","_prepare","schema","preparedString","JSON","stringify","_","value","Function","parse","_find","path","length","str","i","replace","eval","_makeArraySerializer","serializer","array","acc","TYPES","attr","arg","includes","Error","defaultRegex","RegExp","escape","regex","char","preparedSchema","originalSchema","queue","allowedValues","Set","scoped","obj","has","Object","keys","map","prop","usedAcc","Array","from","find","push","isArray","name","type","test","split","chunk","index","chunks","matchProp","matchWhenLast","isLast","matchPropRe","matchStartRe","flag","pure","prevUndef","isUndef","bothUndef","_select","sjs","_makeQueue","_makeChunks","console","log","selectChunk","temp","raw","ready"],"mappings":"6LAOAA,IAAMC,kBAAYC,OACVC,EAAiBC,KAAKC,UAAUH,WAASI,EAAGC,SAC3B,iBAAVA,EAA2BA,EAC/BA,aAAiBC,SACpB,aACGD,kBAKF,gBACLJ,iBAHqBC,KAAKK,MAAMN,KCH9BO,eAASC,UACLC,uBAEJC,IAAM,MAEDC,EAAI,EAAGA,EAAIF,OAAQE,IAC1BD,IAAMA,IAAIE,QAAQ,IAAK,KACvBF,KAAQ,WAAUF,KAAKG,UAGlBE,kBAAkBH,UAUrBI,8BAAwBC,UACxBA,aAAsBV,kBAChBW,WAEFC,EAAM,cAEDN,EAAI,EAAGA,EAAIF,EAAS,EAAGE,IAC9BM,GAAUF,EAAWC,EAAML,mBAI7BM,GAAOF,EAAWC,EAAMP,EAAS,mBAK9BO,UAASf,KAAKC,UAAUc,KAG3BE,MAAQ,CACZ,SACA,SACA,UACA,QACA,QAGIC,cAAQC,EAAKL,OACZG,MAAMG,SAASD,SACZ,IAAIE,2EAA2EF,qBAG3E,UAARA,EACKN,qBAAqBC,GAGvBK,GAKHG,aAAe,IAAIC,OAAO,uBAAwB,MAClDC,gBAAUC,yBAAQH,uBAAiBb,UAAOA,EAAIE,QAAQc,WAAOC,SAAQ,KAAOA,0BClElEC,EAAgBC,OACxBC,EAAQ,GAKRC,EAAgB,IAAIC,IAAI,CAC5B,cACA,cACA,eACA,YACA,+BAKQC,EAAOC,EAAKjB,qBAAM,KACtBc,EAAcI,IAAID,UAyBfE,OACJC,KAAKH,GACLI,aAAIC,UAAQN,EAAOC,EAAIK,GAAWtB,UAAKsB,WA1BlCC,EAAUC,MAAMC,KAAKzB,GACrB0B,EAAOpC,MAAMiC,GACbzB,EAAa4B,EAAKd,GAExBC,EAAMc,KAAK,CAETC,QAAS9B,aAAsBV,oBAI/BU,OAIA4B,EAEAG,KAAMN,EAAQA,EAAQ/B,OAAS,MAWlCmB,GAEIE,wBCjDOpB,EAAKoB,UAAUpB,EAI5BE,QAAQ,wBAAgBmC,SAAS,SAASC,KAAKD,GAAQ,YAAc,YACrEE,MAAM,WACNX,aAAKY,EAAOC,EAAOC,OAIZC,EAAa,MAAKvB,EAAMqB,IAAU,oBAClCG,EAAiB,OAAOD,EAGxBE,EAAS,UAAUP,KAAKI,EAAOD,EAAQ,IAAM,IAI7CK,EAAc,IAAIhC,OAAO+B,EAASD,EAAgBD,GAMlDI,EAAe,sBAEd,CAKLC,MAAM,EACNC,KAAMT,EAENU,UAAWV,EAAMtC,QAAQ6C,EAAc,IAEvCI,QAASX,EAAMtC,QAAQ4C,EAAa,IAEpCM,UAAWZ,EACRtC,QAAQ6C,EAAc,IACtB7C,QAAQ4C,EAAa,QCpCxBO,iBAAUX,mBAAWhD,EAAO+C,OAC1BD,EAAQE,EAAOD,eAEA,IAAV/C,EACL8C,EAAMQ,KACDR,EAAMU,UAAYxD,EAEpB8C,EAAMS,KAAOvD,GAKtBgD,EAAOD,EAAQ,GAAGO,MAAO,EAErBR,EAAMQ,KACDR,EAAMY,UAERZ,EAAMW,WCnBTG,aAAOjE,SACgCD,SAASC,sBAK9C+B,EAAQmC,4BAA2BlE,GACnCqD,EAASc,YAAYlE,EAAgB8B,GAC3CqC,QAAQC,IAAIhB,OACNiB,EAAcN,QAAQX,8BAKpBlB,WACFoC,EAAO,GAGP3D,EAAI,EAEFA,IAAMF,GADC,OAE2BqB,EAAMnB,8BACtC4D,GAAM5B,UAAKT,GAIXsC,EAAQ3B,EACV9B,EAAWwD,GACXA,EACJD,GAAQD,EAAYG,EAAO7D,GAE3BA,GAAK,QAG2ByC,EAAOA,EAAO3C,OAAS,UAElD6D"}