{"version":3,"file":"sjs.mjs","sources":["../src/_utils.mjs","../src/sjs.mjs","../src/_dissectSchema.mjs","../src/_makeQueue.mjs"],"sourcesContent":["// Recursively building an array containing the path of a property in an object.\n// => e.g.\n//      const test = {\n//        a: {\n//          b: {\n//            c: 'test'\n//          }\n//        }\n//      }\n//      deepPath(test, 'c') // ['a', 'b', 'c']\nconst _deepPath = (obj, target) => {\n  for (const key in obj) {\n    if (key === target) return [key];\n    if (obj[key] && typeof obj[key] === 'object') {\n      const result = _deepPath(obj[key], target);\n      if (result) {\n        result.unshift(key);\n        return result;\n      }\n    }\n  }\n};\n\n// Reducing object to final value\nconst _deepFind = (obj, path) => path.reduce((a, b) => a && a[b], obj);\n\nconst _makeArr = (array, method) => {\n  if (method === 'array-simple') return JSON.stringify(array);\n\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  for (const a of array) {\n    acc += method(a) + ',';\n  }\n\n  // Removing last comma.\n  return '[' + acc.substr(0, acc.length - 1) + ']';\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst escape = (regex) => {\n  const usedRegex = regex || new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\n\n  return str => str.replace(usedRegex, char => '\\\\' + char);\n};\n\nconst _scv = (parentObj, allowed) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const types = new Set(allowed);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    const isArray = Array.isArray(obj);\n    if (types.has(_deepFind(parentObj, acc)) || isArray) {\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray,\n        // If the current prop is an array, the array stringification method is stored too.\n        // The method for the array stringification, in SJS, is always stored at 0 position.\n        method: isArray && obj[0],\n\n        // The accumulator is geting one level deeper on each recursive\n        // iteration => flattening on each insertion.\n        // Wrapping `acc` inside an array because, if the prop is found at top level,\n        // a string is pushed inside the queue. Making it already an array will avoid\n        // a type check during stringification as the `deepFind` function accepts an array\n        // as argument.\n        path: [acc].flat(),\n        type: obj,\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(parentObj);\n\n  return queue;\n};\n\n// If this function does not throw => the provided schema is valid.\n// JSON.stringify is used only for convenience as it let's you iterate though every\n// object property.\nconst _validator = (obj) => {\n  // Declaring allowed types.\n  const allowedTypes = new Set(['number', 'string', 'boolean', 'undefined', 'array-simple', 'function']);\n\n  JSON.stringify(obj, (_, value) => {\n    const isArray = Array.isArray(value);\n    if (typeof value !== 'object' || isArray) {\n      if (isArray) {\n        if (allowedTypes.has(value[0]) || allowedTypes.has(typeof value[0])) return;\n\n        // Throwing if inside array is found anything else than \"array-simple\" or new sjs schema\n        throw new Error(`Expected either \"array-simple\" or a function. received ${value}`);\n      } else if (typeof value !== 'function' && !allowedTypes.has(value)) {\n        // Throwing on illegal types\n        // => Mainly protecting users from typo.\n        throw new Error(`Expected one of: \"number\", \"string\", \"boolean\", \"undefined\". received ${value}`);\n      }\n    }\n    return value;\n  });\n};\n\nexport {\n  _deepPath,\n  _deepFind,\n  _makeArr,\n  _validator,\n  _scv,\n  escape,\n};\n","import _dissectSchema from './_dissectSchema';\nimport _makeQueue from './_makeQueue';\nimport { _deepFind, _makeArr, _validator, escape } from './_utils';\n\nconst wrapper = chunks => (value, index) => {\n  if (typeof value !== 'undefined') return value;\n\n  // Checking if template is already wrapping value in double quotes.\n  const current = chunks[index];\n  if (current.charCodeAt(current.length - 1) === 34) return value;\n  return '\"' + value + '\"';\n};\n\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  _validator(schema);\n\n  const { props, str, queue } = _dissectSchema(schema);\n\n  // Building regex that match every prop => Used to enqueue props\n  // => So they will be picked in correct order when building final string.\n  const regex = new RegExp(`${props}\"(string|number|boolean|undef)\"|\\\\[(.*?)\\\\]`, 'gm');\n\n  const { chunks } = _makeQueue(str, regex);\n  const lastChunk = chunks[chunks.length - 1];\n  const readyOrWrapped = wrapper(chunks);\n\n  const { length } = queue;\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { path, method, isArray } = queue[i];\n      const raw = _deepFind(obj, path);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? _makeArr(raw, method)\n        : raw;\n      temp += chunks[i] + readyOrWrapped(ready, i);\n\n      i += 1;\n    }\n\n    return temp + lastChunk;\n  };\n};\n\nexport {\n  sjs,\n  escape,\n};\n","import { _deepPath, _validator, _scv } from './_utils';\n\nexport default (schema) => {\n  // `map` will keep track of the paths of every nested prop\n  const map = {};\n\n  // `arrais` keep track of array properties and the method to be used when stringifying.\n  const arrais = new Map();\n\n  // Accumulator of every prop present in the schema\n  // => Used later to build a regex useful for queueing insertions.\n  let props = '';\n\n  // `str` in the end is simply the native stringification of schema.\n  // => JSON.stringify is used only for convenience.\n  const str = JSON.stringify(schema, (prop, value) => {\n    const isArray = Array.isArray(value);\n    if (typeof value !== 'object' || isArray) {\n      if (isArray) {\n        const current = value[0];\n        arrais.set(prop, current);\n      }\n\n      _validator(value);\n\n      map[prop] = _deepPath(schema, prop);\n      props += `\"${prop}\"|`;\n    }\n    return value;\n  });\n\n  return { map, arrais, props, str, queue: _scv(schema, ['string', 'number', 'boolean', 'array']) };\n};\n","export default (str, regex) => {\n  const queue = [];\n\n  // Replacing types with a string that will make possible:\n  // - Inserting value without adding / removing additional charachters.\n  // - Split templated string in chunks for easier / faster insertion\n  const chunks = str\n    .replace(regex, (type) => {\n      switch (type) {\n        // returning __par__ enclosed by \"\"\n        // => When splitting there will be a \" on each side.\n        case '\"string\"':\n        case '\"undefined\"':\n          return '\"__par__\"';\n\n        // When stringifying a function inside an array [null] is returned.\n        // => Using [null] as an identifier for array schema.\n        case '\"number\"':\n        case '\"boolean\"':\n        case '[\"array-simple\"]':\n        case '[null]':\n          return '__par__';\n        default:\n          // Pushing prop to queue => prop is enclosed by \"\" => matching before pushing\n          const prop = type.match(/(?<=\\\").+?(?=\\\")/)[0];\n          queue.push(prop);\n          return type;\n      }\n    })\n    .split('__par__');\n\n  return { queue, chunks };\n};\n"],"names":["const","_deepPath","obj","target","key","result","unshift","_deepFind","path","reduce","a","b","_makeArr","array","method","JSON","stringify","acc","substr","length","escape","regex","usedRegex","RegExp","str","replace","char","_validator","allowedTypes","Set","_","value","isArray","Array","has","Error","sjs","schema","parentObj","allowed","queue","types","map","arrais","Map","props","prop","set","scoped","Object","keys","push","flat","type","_dissectSchema","chunks","match","split","_makeQueue","lastChunk","readyOrWrapped","index","current","charCodeAt","wrapper","temp","i","raw","ready"],"mappings":"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"}