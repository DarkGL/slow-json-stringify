{"version":3,"file":"sjs.mjs","sources":["../src/_utils.mjs","../src/_prepareString.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/sjs.mjs"],"sourcesContent":["\n\nconst _find = (path) => {\n  const { length } = path;\n\n  let str = 'obj';\n\n  for (let i = 0; i < length; i++) {\n    str = str.replace(/^/, '(');\n    str += ` || {}).${path[i]}`;\n  }\n\n  return eval(`((obj) => ${str})`);\n};\n\nconst _makeArr = (array, method) => {\n  if (method === 'array-simple') return JSON.stringify(array);\n\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  for (const a of array) {\n    acc += `${method(a)},`;\n  }\n\n  // Removing last comma.\n  return `[${acc.slice(0, acc.length - 1)}]`;\n};\n\nconst _validator = (value) => {\n  // Declaring allowed types.\n  const allowedTypes = new Set([\n    'number',\n    'string',\n    'boolean',\n    'undefined',\n    'array-simple',\n    'function',\n  ]);\n\n  if (Array.isArray(value)) {\n    if (allowedTypes.has(value[0]) || allowedTypes.has(typeof value[0])) return;\n\n    // Throwing if inside array is found anything else than \"array-simple\" or new sjs schema\n    throw new Error(`Expected either \"array-simple\" or a function. received ${value}`);\n  } else if (typeof value !== 'function' && !allowedTypes.has(value)) {\n    // Throwing on illegal types\n    // => Mainly protecting users from typo.\n    throw new Error(`Expected one of: \"number\", \"string\", \"boolean\", \"undefined\". received ${value}`);\n  }\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\n\nconst defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst escape = (regex = defaultRegex) => str => str.replace(regex, char => '\\\\' + char);\n\nexport {\n  _find,\n  _makeArr,\n  _validator,\n  escape,\n};\n","import { _validator } from './_utils';\n\nexport default schema => JSON.stringify(schema, (_, value) => {\n  const isArray = Array.isArray(value);\n  if (typeof value !== 'object' || isArray) {\n    // Check if the provided schema is correct\n    _validator(value);\n\n    if (isArray) return value;\n\n    // Type checking is useful as if not performed the resulting string\n    // will have all the function text inside it.\n    // Adding __sjs at the end of the value as there could be an object\n    // property called `string` or `number`, etc...\n    // Adding __sjs at the end is a proof of value not being also an object property.\n    return typeof value === 'function' ? value : `${value}__sjs`;\n  }\n  return value;\n});\n","import { _find } from './_utils';\n\nexport default (preparedSchema, originalSchema) => {\n  const queue = [];\n\n  // Storing the allowed types is useful to know if we are arrived at the deepest level.\n  // If the current value is one of types => the accumulator is storing the path to reach the\n  // target prop.\n  const allowedValues = new Set([\n    'number__sjs',\n    'string__sjs',\n    'boolean__sjs',\n    'undefined__sjs',\n  ]);\n\n  // Defining a function inside an other function is slow.\n  // However it's OK for this use case as the queue creation is not time critical.\n  (function scoped(obj, acc = []) {\n    const isArray = Array.isArray(obj);\n    if (allowedValues.has(_find(acc)(preparedSchema)) || isArray) {\n      queue.push({\n        // Storing iside a unique queue is the current prop is an array or not\n        isArray,\n        // If the current prop is an array, the array stringification method is stored too.\n        // The method for the array stringification, in SJS, is always stored at 0 position.\n        method: (() => {\n          if (!isArray) return false;\n          if (typeof obj[0] === 'string') return 'array-simple';\n\n          // In the prepared schema, due to making the chunks, the functions provided\n          // are converted into NULL.\n          // So, the method is retrieved from the original schema.\n          return _find(acc)(originalSchema)[0];\n        })(),\n\n        // Wrapping `acc` inside an array because, if the prop is found at top level,\n        // a string is pushed inside the queue. Making it already an array will avoid\n        // a type check during stringification as the `deepFind` function accepts only\n        // arrais as arguments.\n\n        // The find function is the function needed to reach that specific property\n        // inside the object.\n        find: _find(Array.isArray(acc) ? acc : [acc]),\n      });\n      return;\n    }\n\n    // Recursively going deeper.\n    // NOTE: While going deeper, the current prop is pushed into the accumulator\n    // to keep track of the position inside of the object.\n    return Object\n      .keys(obj)\n      .map(prop => scoped(obj[prop], [...acc, prop]));\n  })(preparedSchema);\n\n  return queue;\n};\n","export default (str, regex) => str\n  .replace(regex, (type) => {\n    switch (type) {\n      // returning __par__ enclosed by \"\"\n      // => When splitting there will be a \" on each side.\n      case '\"string__sjs\"':\n      case '\"undefined__sjs\"':\n        return '\"__par__\"';\n\n      // When stringifying a function inside an array [null] is returned.\n      // => Using [null] as an identifier for array schema.\n      case '\"number__sjs\"':\n      case '\"boolean__sjs\"':\n      case '[\"array-simple__sjs\"]':\n      case '[null]':\n        return '__par__';\n      default:\n        return type;\n    }\n  })\n  .split('__par__');\n","import _prepareString from './_prepareString';\nimport _makeQueue from './_makeQueue';\nimport _makeChunks from './_makeChunks';\nimport { _makeArr, escape } from './_utils';\n\nconst wrapper = chunks => (value, index) => {\n  if (typeof value !== 'undefined') return value;\n\n  // Checking if template is already wrapping value in double quotes.\n  const current = chunks[index];\n  if (current.charCodeAt(current.length - 1) === 34) return value;\n  return '\"' + value + '\"';\n};\n\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const preparedString = _prepareString(schema);\n\n  // Building regex that match every prop => Used to enqueue props\n  // => So they will be picked in correct order when building final string.\n  const regex = new RegExp('\"(string__sjs|number__sjs|boolean__sjs|undefined__sjs)\"|\\\\[(.*?)\\\\]', 'gm');\n\n  const chunks = _makeChunks(preparedString, regex);\n  const lastChunk = chunks[chunks.length - 1];\n  const readyOrWrapped = wrapper(chunks);\n\n  const preparedSchema = JSON.parse(preparedString);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(preparedSchema, schema);\n\n  const { length } = queue;\n  // Exposed function\n  return (obj) => {\n    let temp = '';\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { method, isArray, find } = queue[i];\n      const raw = find(obj);\n\n      // An array needs a different treatment\n      // => This will make possible the stringification of an arbitrary number of arrais\n      const ready = isArray\n        ? _makeArr(raw, method)\n        : raw;\n      temp += chunks[i] + readyOrWrapped(ready, i);\n\n      i += 1;\n    }\n\n    return temp + lastChunk;\n  };\n};\n\nexport {\n  sjs,\n  escape,\n};\n"],"names":["const","_find","path","length","str","i","replace","eval","_makeArr","array","method","JSON","stringify","acc","slice","_validator","value","allowedTypes","Set","Array","isArray","has","Error","defaultRegex","RegExp","escape","regex","char","schema","_","preparedSchema","originalSchema","queue","allowedValues","scoped","obj","Object","keys","map","prop","push","find","type","split","wrapper","chunks","index","current","charCodeAt","sjs","preparedString","_prepareString","_makeChunks","lastChunk","readyOrWrapped","parse","_makeQueue","temp","raw","ready"],"mappings":"AAEAA,IAAMC,eAASC,UACLC,uBAEJC,IAAM,MAEDC,EAAI,EAAGA,EAAIF,OAAQE,IAC1BD,IAAMA,IAAIE,QAAQ,IAAK,KACvBF,KAAQ,WAAUF,KAAKG,UAGlBE,kBAAkBH,UAGrBI,kBAAYC,EAAOC,MACR,iBAAXA,EAA2B,OAAOC,KAAKC,UAAUH,WAGjDI,EAAM,SACMJ,kBACdI,GAAUH,sBAIDG,EAAIC,MAAM,EAAGD,EAAIV,OAAS,QAGjCY,oBAAcC,OAEZC,EAAe,IAAIC,IAAI,CAC3B,SACA,SACA,UACA,YACA,eACA,gBAGEC,MAAMC,QAAQJ,GAAQ,IACpBC,EAAaI,IAAIL,EAAM,KAAOC,EAAaI,WAAWL,EAAM,IAAK,aAG/D,IAAIM,gEAAgEN,GACrE,GAAqB,mBAAVA,IAAyBC,EAAaI,IAAIL,SAGpD,IAAIM,+EAA+EN,IAOvFO,aAAe,IAAIC,OAAO,uBAAwB,MAClDC,gBAAUC,yBAAQH,uBAAiBnB,UAAOA,EAAIE,QAAQoB,WAAOC,SAAQ,KAAOA,8BCrDnEC,UAAUjB,KAAKC,UAAUgB,WAASC,EAAGb,OAC5CI,EAAUD,MAAMC,QAAQJ,SACT,iBAAVA,GAAsBI,GAE/BL,WAAWC,GAEPI,EAAgBJ,EAOI,mBAAVA,EAAuBA,EAAWA,WAE3CA,yBCfOc,EAAgBC,OACxBC,EAAQ,GAKRC,EAAgB,IAAIf,IAAI,CAC5B,cACA,cACA,eACA,mCAKQgB,EAAOC,EAAKtB,kBAAM,QACpBO,EAAUD,MAAMC,QAAQe,OAC1BF,EAAcZ,IAAIpB,MAAMY,EAANZ,CAAW6B,MAAoBV,SA+B9CgB,OACJC,KAAKF,GACLG,aAAIC,UAAQL,EAAOC,EAAII,GAAW1B,UAAK0B,OAhCxCP,EAAMQ,KAAK,SAETpB,EAGAV,SACOU,IACiB,iBAAXe,EAAI,GAAwB,eAKhClC,MAAMY,EAANZ,CAAW8B,GAAgB,IAUpCU,KAAMxC,MAAMkB,MAAMC,QAAQP,GAAOA,EAAM,CAACA,OAW3CiB,GAEIE,wBCvDO5B,EAAKsB,UAAUtB,EAC5BE,QAAQoB,WAAQgB,UACPA,OAGD,oBACA,yBACI,gBAIJ,oBACA,qBACA,4BACA,eACI,yBAEAA,KAGZC,MAAM,YCfHC,iBAAUC,mBAAW7B,EAAO8B,WACX,IAAV9B,EAAuB,OAAOA,MAGnC+B,EAAUF,EAAOC,UACwB,KAA3CC,EAAQC,WAAWD,EAAQ5C,OAAS,GAAkBa,EACnD,IAAMA,EAAQ,MAMjBiC,aAAOrB,OACLsB,EAAiBC,eAAevB,GAIhCF,EAAQ,IAAIF,OAAO,sEAAuE,MAE1FqB,EAASO,YAAYF,EAAgBxB,GACrC2B,EAAYR,EAAOA,EAAO1C,OAAS,GACnCmD,EAAiBV,QAAQC,GAEzBf,EAAiBnB,KAAK4C,MAAML,GAK5BlB,EAAQwB,WAAW1B,EAAgBF,8BAIjCO,WACFsB,EAAO,GAGPpD,EAAI,EAEFA,IAAMF,GADC,OAEuB6B,EAAM3B,0BAClCqD,GAAMjB,UAAKN,GAIXwB,EAAQvC,EACVZ,SAASkD,EAAKhD,GACdgD,EACJD,GAAQZ,EAAOxC,GAAKiD,EAAeK,EAAOtD,GAE1CA,GAAK,SAGAoD,EAAOJ"}